
### Investigation of Failing Tests

The failures can be broken down into three core mismatches between the test suite and the component.

#### 1. Mismatch: Validation Logic (`onSubmit` vs. `onChange`)

The component is configured to validate when the user clicks submit, but the tests expect errors to appear immediately as the user types. This accounts for the majority of the "Form Validation" failures.

*   **Component Code (`ContributionForm.tsx`):**
    ```typescript
    // ...
    const { 
      // ...
    } = useForm<ContributionFormData>({
      mode: 'onSubmit', // <-- This is the key line
      // ...
    });
    // ...
    ```
    The `mode: 'onSubmit'` configuration tells `react-hook-form` to delay validation until the `handleSubmit` function is triggered.

*   **Failing Test Code (`ContributionForm_test.tsx`):**
    ```typescript
    // ...
    it('should require toilet name', async () => {
      // ...
      // No submit action is performed here
      await waitFor(() => {
        // This fails because the 'errors' object is still empty
        expect(screen.getByText(/toilet name is required/i)).toBeInTheDocument(); 
      });
      // ...
    });
    // ...
    ```
    This test, and others like it (`should validate name length`), expect the error message to be present *without* a submit event. Because the component is in `onSubmit` mode, the test times out waiting for an error that will never appear under these conditions.

#### 2. Mismatch: User Interaction Simulation

The tests are attempting to interact with form elements in a way that is inconsistent with their implementation.

*   **Component Code (`ContributionForm.tsx`):**
    The component renders a standard HTML `<select>` element for the "Opening Hours".
    ```jsx
    // ...
    <select {...register('hours')}>
      <option value="">Select hours...</option>
      <option value="24/7">24/7</option>
      // ...
    </select>
    // ...
    ```

*   **Failing Test Code (`ContributionForm_test.tsx`):**
    The test for a valid submission attempts to *type* into this field instead of *selecting* an option.
    ```typescript
    // ...
    it('should allow valid form submission', async () => {
      // ...
      const hoursInput = screen.getByLabelText(/opening hours/i);
      await user.type(hoursInput, '9am - 5pm'); // <-- Incorrect interaction
      // ...
    });
    // ...
    ```
    `userEvent.type` on a `<select>` element does not work as it does on an `<input>`. The test must be updated to use `userEvent.selectOptions` to correctly simulate user behavior. This single incorrect interaction causes the form's Zod schema to fail validation (because `hours` is empty), preventing the `mockOnSubmit` function from ever being called and failing the test.

#### 3. Mismatch: Asynchronous State and Error Handling

The accessibility test for announcing errors fails because it doesn't correctly wait for the asynchronous validation process to complete.

*   **Component Code (`ContributionForm.tsx`):**
    The entire submission and validation process is asynchronous.
    ```typescript
    // ...
    const handleFormSubmit = async () => {
      // ...
      const validationResult = formSchema.safeParse(formDataWithFee);
      // ...
      if (!validationResult.success) {
        // ...
        setManualErrors(newErrors); // <-- State update is async
        // ...
        return;
      }
      // ...
    }
    // ...
    ```

*   **Failing Test Code (`ContributionForm_test.tsx`):**
    The test checks for the error message without properly waiting for the state update that renders it.
    ```typescript
    // ...
    it('should announce form errors to screen readers', async () => {
      // ...
      await user.click(submitButton);

      // This check runs immediately, but the error state hasn't been set yet.
      const errorAlert = screen.getByRole('alert'); 
      expect(errorAlert).toBeInTheDocument();
      // ...
    });
    // ...
    ```
    While the test is an `async` function, the `getByRole('alert')` query runs synchronously after the click. It fails because the error `div` has not been rendered yet. The fix is to use an asynchronous query, like `findByRole('alert')`, which will wait for the element to appear.
